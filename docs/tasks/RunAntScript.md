## RunAntScript

This task is the base for other tasks that run MPS-generated Ant scripts (`BuildLanguages`, `TestLanguages`).

The custom tasks are useful when you don't check in the build scripts generated by MPS into source control but want to
generate them during the Gradle build. In that case you can't use the Ant integration of Gradle to run these files
because they may not exist yet when the build is started.

### Usage

Parameters:

- `script`: path to the ANT to execute
- `scriptClasspath`: classpath used for the JVM that will execute the generated ANT script. Needs to contain ANT to be
  able to run the build script. See below section "Providing Global Defaults" for project wide defaults.
- `scriptArgs`: additional command line arguments provided to the JVM that will execute the generated ANT scripts. This
  is often used to provide property valued via `-Dprop=value`. See below section "Providing Global Defaults" for project wide defaults.
- `executable`: the `java` executable to use. Optional. If `itemis.mps.gradle.ant.defaultJavaExecutable` extended
  property is set, its value is used as the default value for the parameter.
- `includeDefaultArgs`: controls whether the project-wide default values for arguments are used.
  It's set to `true` by default.
- `includeDefaultClasspath`: controls whether the project-wide default values for the classpath are used.
  It's set to `true` by default.
- `targets`: the targets to execute of the ANT files.
- `incremental`: enable incremental build, see below. (Since 1.6.)

### Providing Global Defaults For Class Path And Arguments

All tasks derived from the `RunAntScript` base class allow to specify default values for the classpath and script arguments
via project properties. By default, these values are added to the value specified for the parameters `scriptArgs` and
`scriptClasspath` if they are present. To opt out from the defaults see above the parameters `includeDefaultArgs` and
`includeDefaultClasspath`.

The property `itemis.mps.gradle.ant.defaultScriptArgs` controls the default arguments provided to the build scripts
execution. In belows example the default arguments contain the version and build date. At runtime the default arguments
are combined with the arguments defined via `scriptArgs`.

The property `itemis.mps.gradle.ant.defaultScriptClasspath` controls the default classpath provided to the build scripts
execution. In belows example the classpath contains ANT (via dependency configuration) and the tools jar from the JDK.
At runtime the default classpath are combined with the classpath defined via `scriptClasspath`.
```
def defaultScriptArgs = ["-Dversion=$version", "-DbuildDate=${new Date().toString()}"]
def buildScriptClasspath = project.configurations.ant_lib.fileCollection({true}) + project.files("$project.jdk_home/lib/tools.jar")

ext["itemis.mps.gradle.ant.defaultScriptArgs"] = defaultScriptArgs
ext["itemis.mps.gradle.ant.defaultScriptClasspath"] = buildScriptClasspath
```

### Providing Global Defaults For The Java Executable

The `itemis.mps.gradle.ant.defaultJavaExecutable` property specifies the value to use as the underlying
`JavaExec.executable`. The `executable` parameter of each individual task takes precedence over the global default.

### Incremental Builds

Incremental builds can be enabled by setting the `incremental` property to `true`. This has the following effects:
* The `clean` target is removed from the `targets` list.
* Argument `-Dmps.generator.skipUnmodifiedModels=true` is passed to Ant. This property tells the MPS generator to skip
  generating and compiling models that have not been modified.

NOTE: While incremental builds are convenient, it is necessary to be aware of their limitations. To determine whether
a model should be regenerated the generator only looks at the hash of the model contents. If the contents have not
changed since the last generation the generation is skipped. This may not be fully correct in the general case. Changing
the generator of a language used by the model may affect the generated code for the model, for example. Changes in
imported models may affect the generation output of this model as well. None of these changes would be detected via the
model contents hash.
